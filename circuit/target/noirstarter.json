{"noir_version":"0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704","hash":4012150433739636972,"abi":{"parameters":[{"name":"pub_key","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"hashed_message","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"public"},{"name":"claimer_pub","type":{"kind":"field"},"visibility":"public"}],"param_witnesses":{"claimer_pub":[{"start":161,"end":162}],"hashed_message":[{"start":128,"end":160}],"nullifier":[{"start":160,"end":161}],"pub_key":[{"start":0,"end":64}],"signature":[{"start":64,"end":128}]},"return_type":null,"return_witnesses":[]},"bytecode":"H4sIAAAAAAAA/+2dBXRU1xPGd5MQ2whJIDgEd9iNkARd3AuUQo22QAmFFgq0tNShDqXubtTd3d3d3d3d+5/JzjST6ZKG5i7NnP9953zn22/f5t3fu/vm7Sa7L7MgGAjcGogtcDOQRLfTRQ6qnKRyssopKjdROVXlNJXTVc5QOVPlkMpZKmernKNyrspNVc5TOV/lApWbqdxc5UKVW6jcUuVWKrdWuY3KbVVup3J7lTuoXKRyR5U7qdxZ5S4qd1W5m8rdVe6hck+Ve6ncW+U+KvdVuZ/K/VUOqxxRuVjlEpVLVS5TeYDK5SpXqFyp8kCVB6k8WOUhKg9VeZjKUZWHqzxC5ZEqj1J5tMpjVB6r8jiVx6s8QeWJKk9SebLKm6g8ReWpKk9TeVOVp6u8mcozVJ6p8uYqb6HylipvpfLWKs9SeRuVt1V5O5VnqzxH5bkqb6/yPJWrVJ6v8g4qL1B5oco7qryTyotUXqzyziovUXmpystU3kXlXVVervJuKu+u8gqV91B5T5X3UnlvlfdReV+V91N5pcqrVN5f5QNUPlDlg1Q+WOVDVD5U5dUqr1H5MJXXqny4ykeofKTKR6l8tMrHqHysysepfLzKJ6h8osonqXyyyqeofKrKp6l8uspnqHymymdRTqb7AuTRQO2F1/H94YYtEYfbCieKMWiAMckAY7IBxhQDjE0MMKYaYEwzwJhugDHDAGOmAcaQAcYsA4zZBhhzDDDmGmBsaoAxzwBjvgHGAgOMzQwwNjfAWGiAsYUBxpYGGFsZYGxtgLGNAca2BhjbGWBsb4CxgwHGIgOMHQ0wdjLA2NkAYxcDjF0NMHYzwNjdAGMPA4w9DTD2MsDY2wBjHwOMfQ0w9jPA2N8AY9gAY8QAY7EBxhIDjKUGGMsMMA4wwFhugLHCAGOlAcaBBhgHGWAcbIBxiAHGoQYYhzlkTBKMRXT7XNA60Hmg80EXgC4EXQS6GHQJ6FLQZaDLQVeArgRdBboadA3oWtB1oOtBN4BuBN0Euhl0SyB2Xc5toNtBd4DuBN0Fulux3AO6F3Qf6H7QA6AHQQ+BHgY9AnoU9BjocdAToCdBT4GeBj0Dehb0HOh50AugF0EvgV4GvQJ6FfQa6HXQG6A3QW+B3gYdR08efheI54oX/C5YsuPnNlVs3802S8OpAefHYFjOB3uGmA92/E5fplgfiPMzzJZCnkNzm+qWuTiDeOQSVDkqbqcKz3DKUlw9f2kbwJIhWNKdssSOuUy326w+5kKOt4nbyBJzwvPH7CGxPiTmK8vxfAXFmLxdzpLPs3pWz+pZPatn9aye1bN6Vs/qWT2rZ/WsntWzelbP6lmtsOL4TRRnhnhck0bAx/elJ46lOEOx4FLX3+6zBEuuU5bY5wjZG8CSK1hynLLEPkdo6nab1X/zzxP8vK88Tkisl/WR53jfgmJM3i5nyedZPatn9aye1bN6Vs/qWT2rZ/WsntWzelbP6lk9q2f1rFZY5d/UmTNDPC6zEfDxfTmCxfXfoXGf+foE3jbmHsGaMd1+L784HAzU/t5/VDDwWMniMcOCNVx9gjXPD6/nz2fktQfyMxvH11tUP3/yGoeoyDwW97sJBGp/9qU/B0PmkLovUZ8zhRQz5ywxPvOH4vBlCOefSRf3Zav9xfvkscv3JcUZI1mxyONS1ic/rzliLIvHglwfEHOSIn5Gb8f9cVFcfT1LttNtxnoE5Ij94X3ncZLF+omitieLa9Lk8cLrZ8VZz0t9P6d0ff7EcfPE9qNiDDluvttxI3LcIInH4PuTxe2txQTl19z8a37l615unMfJ26nqZ0JifW6C93l9r5s8Fh4nU8UxNUu8joUc88j95TF4XJ4XXi9r2XW94S7mBGrPiz53yu84yNriY1Suc/tZfowvS/FxzhV8+vsgmYHar03M3Fjeo8laaZowltj7Jc2Solgc1FtE34HjFojtDw/8vd6SxWOWUa3xMVcgmJPUPGWKbcgxmjdsH/42d7jNQqfbjNV9C9oWPg98DBSKOeH1e4hz0V7i9Yv3OUtsZ02c9bzU9frWXMxfK7f7Wn0MtBbbj4ox5Lht3I4bkePy6xuPwfcni9urxQS1qbn51/wyMx53LeM8Tt4uUD8TEutbJnifWwmOqMg8Fh4n+4pjao14fWvmmEfur5wX+frG6/PFfZnq8Xg8cz3Ic7brugyKcXi7nAsFH9/XTPDJa/R5H/l3YF17ToFx8CLa3rmB2JvldeTnkZ9PfgH5heQXkV9Mfgn5peSXkV9OfgX5leRXkV9Nfg35teTXkV9PfgP5jeQ3kd9Mfgv5reS3kd9Ofgf5neR3kd9NXkTzcA/le8nvI7+f/AHyB8kfIn+Y/BHyR8kfI3+c/AnyJ8mfIn+a/BnyZ8mfI3+e/AXyF8lfIn+Z/BXyV8lfI3+d/A3yN8nfIn+bPErzEKU8nHwEOTfv5Kad3KxzDPlY8nHk48knkE8kn0Q+mZybbHJzzank08i5iSY3z+Smmdwsk5tkcnNMborJzTC5CSY3v+Sml9zskptccnPL2eRzyOeSc/NKblrJzSrnk+9AvoB8IfmO5DuRLyJfTM5NJrm55FLyZeTcRJKbR3LTSG4WyU0iuTkkN4XkZpDcBJKbP3LTR272yE0eubljUSC2rKK8P/kB5NzEkZs3ctPGQ8gPJV9Nvob8MPK15IeTH0HOzRa5yeLR5MeQczNFbqLIzRO5aSI3S+QmidwckZsicjNEboLIzQ+56SE3O+Qmh+8Eai98Qo6Shxu2RN4R2yoJDygtrSovroqUROaEiyvnVpSFS8vmDqiIVETKKsrmFVeUlFRVlFaUV86tLA9XRkpLqiLzyypL5tPG8E1JkuAsSjD7ue62FU4U4zoDjOcZYDzfAOMFBhgvNMB4kQHGiw0wXmKA8VIDjJcZYLzcAOMVBhivNMB4lQHGqw0wXmOA8VoDjNcZYLzeAOMNBhhvNMB4kwHGmw0w3mKA8VYDjLcZYLzdAOMdBhjvNMB4lwHGux0yboy/Rd5jYE7vNcB4nwHG+w0wPmCA8UEDjA8ZYHzYAOMjBhgfNcD4mAHGxw0wPmGA8UkDjE8ZYHzaAOMzBhifNcD4nAHG5w0wvmCA8UUDjC8ZYHzZAOMrBhhfNcD4mgHG1w0wvmGA8U0DjG8ZYHzbIWNQMPI23wW9B3of9AHoQ9BHoI9Bn4A+BX0G+hz0BehL0Fegr0HfgL4FfQf6HvQD6EfQT6CfQb+AfgX9Bvod9AfoTwIIgpJAyaAUUBNQKigNlA7KAGWCQqAsUDYoB5QLagrKA+WDCkDNQM1BhaAWoJagVqDWoDagtqB2oPagDqAiUEdQJ9BampSN1ZBRXvQQFOM0cTyOvFDXzTb/28aPct5SxH08b9LlhesBtW1uBum2AWPsnzinB2ovQZWj4rb8RwxuLy4vDTfkH0q7vlg3ARfehhPwz6arz9/yomL9T0rkRcXynysk4qLdbPU8cZZ8ntWzelbP6lk9q2f1rJ7Vs3pWz+pZPatn9aye1bN6Vs/qWT2rZ/WsntWzelbP6lk9q2f1rJ7Vs3pWz+pZPatn9aye9f+bFVnSFadsLpbeCPjkvDFLtluWsGxyxdvG75u3D9aMmel0zPiN+WQTM1xkY765wRquToLL8Xfaw7KZm2wI1nUjz0VaHXNRIuaiZ7Dmcbw+XfCH1H3uv3tf/4Z/vC/1bfgnazIpzs/qRn5pRuchEc324rGkKRYH55K4jZzkeX244OCxZFO+ocHa62RzMb7mRdaCfpz7Rnuxa35cN/nCbcjGcXwMyAZ6vH60qO+x4lot3md5XpoZZz0vQZWj4rZsIua4mU/1MSAbNkXFGHLcRDTlaS72PSjG4PuTxe0ZYoIKa27+Nb/MjM9VQZzHyds56mdCYn1Bgve5meCIisxj4XEyQRxTM8Vrmev3NXJ/5byEhPN6+d4mXT0enwOuB3nOTkTzvXw1f7q55fqaTm4MljTFIt+fyPNJV8PvA+R6XJIEI/+M3o776+Fi5/1E1INsds37zuMki/U7ixpdKs7rslExr18ZZz0vdZ335eum46apf2viGBVjyHFdN4+T4/J5n8fg+2XzyP3EBMlzJ88vM+NzlRfncfJ2lvqZkFifl+B9Xt95i8fC42RXcUytFOd9x79DRuT+ynlJFfMiz6e8LhG/VzcN1J4XZoj3e7+sLT5GE/16oxvocpbzw/dlCz7eD3k+4d/Rdc07fWJ50RfCN7SBVeegu5M3suUKtnfpiXyP/H3yD8g/JP+I/GPyT8g/Jf+M/HPyL8i/JP+K/Gvyb8i/Jf+O/HvyH8h/JP+J/GfyX8h/Jf+N/HfyP8j/JMcnBT1InkSeTJ5C3oQ8lTyNPJ08gzyTPESeRZ5NnkOeS96UPI88n7yAvBl5c/JC8hbkLclbkbcmb0PelrwdeXvyDuRF5B3JO5HjsVUUiAmXLsHYm6RuoO7BWMdN/ONJL1BvUB9QX1A/UH8QHlBYrcXB2B9cSkFloAGgclAFqBI0EDQINBg0JBj7hXYYHteg4aARoJGqOvU/2GhoHZ0TqEcdRcL1W4LuuEYH3b25qGv+6vixeu11pL6c9dhascP5G/Pfz1+4PntdsiGc/7C1UofzN7ZxzF/4n/a6bEM569jaAIfzN67xzF+4rr0u/zec69lahcP5G9+45i+8vr2u/LeccbY20OH8TWh88xeOt9eDGsKptjbY4fxNbJzzF9Z7PaShnGJrQx3O36TGO39hudfDXHDS1qIO529y456/MO/1cFecsLURDudvk8Y/f7hERrrjjIx2OH9TjMyfw/f5kbEO52+qkflz+D41Mt7h/E0zMn8O32dFJjqcv02NzJ/D9wmRyQ7nb7qR+XP4OheZ4nD+NjMyfw7P05FpDudvhpH5c3ieiUx3OH8zjcyfwzqJODxmIi7nD/+Eny7mDB0/ixlOPoJ8JPko8tHkY8jHko8jH08+gXwi+STyyeSbkE8hn0o+jXxT8unkm5HPIJ9Jvjn5FuRbkm9FvjX5LPJtyLcl3458Nvkc8rnk25PPI68in0++A/kC8oXkO5LvRL6IfDH5zuRLyJeSLyPfhXxX8uXku5HvTr6CfA/yPcn3It+bfB/yfcn3I19Jjsso9bkOf3ElSt7Q+j874K4WRjmshVVin4O033hOwQ+k8Z+R4wfV+CWl6s8VAzVf4MEP2/EDbfxwGz+rxQ+y8UNv/OICfjkDv7iAX87DL661ALUEtQK1BrUBtQW1A7UHdQjEPtvrCOoE6gzqAuoK6gbqDuoB6gnqBeoN6gPqC+oH6o/zAMIPuIvxuQKVgspAA0DloApQJWggaBBoMGgIaChoGD03WP9Y+1j3WPNY71jrWOdY41jfWNtY11jTWM9Yy1jHWMNYv1i7WLdYs1ivWKtYp1ijWJ9Ym1iXWJNYj1iLWIezA7H6w9rDusOaw3rDWsM6wxrD+sLawrrCmsJ6wlrCOsIawvrB2sG6wZrBesFawTrBGsH6wNrAusCawHrAWlhJ847LKtD+oANAB4IOAh0MOgR0KGg1aA3oMNBa0OGgI0BHgo4CHQ06BnQs6DjQ8aATQCeCTgKdDDoFdCroNNDpoDNAZ4LOAp0NOidQs3AdBmkdLvyFqraU5yxfXrV46fKi5UuK5sybV7Ri4fIFRUt2r9pl/qIlK/Ch6+hxQzbg5/4H/sq2tC4HAQA=","debug_symbols":"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","file_map":{"24":{"source":"mod poseidon;\nmod mimc;\n\n#[foreign(sha256)]\npub fn sha256<N>(_input: [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\npub fn blake2s<N>(_input: [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake3)]\npub fn blake3<N>(_input: [u8; N]) -> [u8; 32] {}\n\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(_input: [Field; N], _separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\npub fn pedersen_hash<N>(input: [Field; N]) -> Field {\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(_input: [Field; N], _separator: u32) -> Field {}\n\npub fn hash_to_field<N>(_input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = _input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\npub fn keccak256<N>(_input: [u8; N], _message_size: u32) -> [u8; 32] {}\n\n","path":"std/hash.nr"},"39":{"source":"use dep::std;\nuse dep::ecrecover;\n\nglobal DEPTH = 12;\n\nfn main(\n    pub_key: [u8; 64],\n    signature: [u8; 64],\n    hashed_message: pub [u8; 32],\n    nullifier: pub Field,\n    claimer_pub: pub Field\n) {\n    let key = ecrecover::secp256k1::PubKey::from_unified(pub_key);\n    let address = ecrecover::ecrecover(key.pub_x, key.pub_y, signature, hashed_message);\n    let signature_as_fields = signature.map(|x : u8| x as Field);\n    let calculatedNullifier = std::hash::pedersen_hash(signature_as_fields);\n    assert(address == claimer_pub);\n    assert(calculatedNullifier == nullifier);\n}\n\n#[test]\nfn test_main() {\n    let pub_key = [\n        131,  24,  83,  91,  84,  16, 93,  74, 122, 174,  96,\n        192, 143, 196,  95, 150, 135, 24,  27,  79, 223, 198,\n        37, 189,  26, 117,  63, 167, 57, 127, 237, 117,  53,\n        71, 241,  28, 168, 105, 102, 70, 242, 243, 172, 176,\n        142,  49,   1, 106, 250, 194, 62,  99,  12,  93,  17,\n        245, 159,  97, 254, 245, 123, 13,  42, 165\n    ];\n    let signature = [\n        1,  83,  82, 167, 184,  77, 226, 104,   5,  27, 151,\n        91, 202, 127,  17, 183,  75,  31, 190, 253, 159, 116,\n        155,  13,  24, 178,  40, 165, 129,  90, 103, 204,  42,\n        164, 230,  62,  73, 181, 169,  61, 251, 221, 128, 221,\n        14,  19, 179,  25, 107, 132,  10, 188, 149,   0, 197,\n        52, 151, 239, 244, 103, 215, 224,  56, 242\n    ];\n    let hashed_message = [\n        3,  57, 199, 96, 145,  58, 183, 241,\n        206, 140,  36, 34, 165, 163,  17, 210,\n        97, 254, 154, 79,  91, 223, 149,  18,\n        3, 210, 111, 56, 246, 219,  19, 104\n    ];\n\n    let claimer = 0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc;\n    let nullifier = 0x24607bdb5f755cb96c74f4fd30ae8595cfca37b9677124f65bb811c1583663ea;\n    main(pub_key, signature, hashed_message, nullifier, claimer);\n}\n","path":"/Users/godson/Desktop/tikswap/circuit/src/main.nr"},"40":{"source":"use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/godson/nargo/github.com/colinnielsen/ecrecover-noir.gitv0.19.0/src/lib.nr"},"41":{"source":"use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/godson/nargo/github.com/colinnielsen/ecrecover-noir.gitv0.19.0/src/secp256k1.nr"},"42":{"source":"use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n","path":"/Users/godson/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"}}}