{
  "noir_version": "0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704",
  "hash": 8753129867605873342,
  "abi": {
    "parameters": [
      {
        "name": "pub_key",
        "type": {
          "kind": "array",
          "length": 64,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signature",
        "type": {
          "kind": "array",
          "length": 64,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "hashed_message",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      { "name": "claimer_pub", "type": { "kind": "field" }, "visibility": "public" }
    ],
    "param_witnesses": {
      "claimer_pub": [{ "start": 160, "end": 161 }],
      "hashed_message": [{ "start": 128, "end": 160 }],
      "pub_key": [{ "start": 0, "end": 64 }],
      "signature": [{ "start": 64, "end": 128 }]
    },
    "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" },
    "return_witnesses": [323]
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "24": {
      "source": "mod poseidon;\nmod mimc;\n\n#[foreign(sha256)]\npub fn sha256<N>(_input: [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\npub fn blake2s<N>(_input: [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake3)]\npub fn blake3<N>(_input: [u8; N]) -> [u8; 32] {}\n\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(_input: [Field; N], _separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\npub fn pedersen_hash<N>(input: [Field; N]) -> Field {\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(_input: [Field; N], _separator: u32) -> Field {}\n\npub fn hash_to_field<N>(_input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = _input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\npub fn keccak256<N>(_input: [u8; N], _message_size: u32) -> [u8; 32] {}\n\n",
      "path": "std/hash.nr"
    },
    "39": {
      "source": "use dep::std;\nuse dep::ecrecover;\n\nglobal DEPTH = 12;\n\nfn main(\n  pub_key: [u8; 64],\n  signature: [u8; 64],\n  hashed_message: pub [u8; 32],\n  claimer_pub: pub Field\n) -> pub Field {\n    let key = ecrecover::secp256k1::PubKey::from_unified(pub_key);\n    let address = ecrecover::ecrecover(key.pub_x, key.pub_y, signature, hashed_message);\n    let signature_as_fields = signature.map(|x : u8| x as Field);\n    let nullifier = std::hash::pedersen_hash(signature_as_fields); \n    assert(address == claimer_pub );\n    nullifier\n}\n\n\n// #[test]\n// fn test_main() {\n//     let pub_key = [\n//         131,  24,  83,  91,  84,  16, 93,  74, 122, 174,  96,\n//         192, 143, 196,  95, 150, 135, 24,  27,  79, 223, 198,\n//         37, 189,  26, 117,  63, 167, 57, 127, 237, 117,  53,\n//         71, 241,  28, 168, 105, 102, 70, 242, 243, 172, 176,\n//         142,  49,   1, 106, 250, 194, 62,  99,  12,  93,  17,\n//         245, 159,  97, 254, 245, 123, 13,  42, 165\n//     ];\n//     let signature = [\n//         1,  83,  82, 167, 184,  77, 226, 104,   5,  27, 151,\n//         91, 202, 127,  17, 183,  75,  31, 190, 253, 159, 116,\n//         155,  13,  24, 178,  40, 165, 129,  90, 103, 204,  42,\n//         164, 230,  62,  73, 181, 169,  61, 251, 221, 128, 221,\n//         14,  19, 179,  25, 107, 132,  10, 188, 149,   0, 197,\n//         52, 151, 239, 244, 103, 215, 224,  56, 242\n//     ];\n//     let hashed_message = [\n//         3,  57, 199, 96, 145,  58, 183, 241,\n//         206, 140,  36, 34, 165, 163,  17, 210,\n//         97, 254, 154, 79,  91, 223, 149,  18,\n//         3, 210, 111, 56, 246, 219,  19, 104\n//     ];\n\n//     let claimer = 0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc;\n//     main(pub_key, signature, hashed_message, claimer);\n// }\n",
      "path": "/Users/godson/Desktop/tikswap/circuit/src/main.nr"
    },
    "40": {
      "source": "use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/godson/nargo/github.com/colinnielsen/ecrecover-noir.gitv0.19.0/src/lib.nr"
    },
    "41": {
      "source": "use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/godson/nargo/github.com/colinnielsen/ecrecover-noir.gitv0.19.0/src/secp256k1.nr"
    },
    "42": {
      "source": "use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n",
      "path": "/Users/godson/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"
    }
  }
}
